---
description: Performance optimization guidelines — activated for performance-sensitive code
globs: "**/*cache*.{ts,js}, **/*query*.{ts,js}, **/*loader*.{ts,js}, **/hooks/use*.{ts,tsx}"
alwaysApply: false
---

# Performance Rules

## First Principles

1. **Measure before optimizing** — profile, don't guess
2. **Correctness before performance** — fast + wrong = useless
3. **Optimize the bottleneck** — 80% of time is in 20% of code

## Database

- **No N+1 queries** — use `include`, `join`, or dataloader
- **Index every WHERE, JOIN, ORDER BY column** — check query plans
- **Paginate large result sets** — cursor-based for >1000 rows

## React

- **useMemo / useCallback** — ONLY when measured performance issue exists
- **React.memo** — ONLY for components that re-render often with same props
- **Virtualize lists > 100 items** — use @tanstack/react-virtual
- **Lazy load heavy components** — `React.lazy()` + `Suspense`
- **Avoid re-render cascades** — don't put frequently-changing state in Context

## Network

- **Batch API calls** — `Promise.all` for independent requests
- **Cache server data** — TanStack Query / SWR with appropriate staleTime
- **Debounce user input** — search, resize, scroll handlers (300ms default)
- **Compress responses** — gzip/brotli on server

## Build

- **Code split by route** — dynamic `import()` for route components
- **Tree-shake** — use ESM, avoid barrel re-exports of large modules
- **Optimize images** — WebP/AVIF format, responsive sizes, lazy loading
