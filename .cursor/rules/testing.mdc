---
description: TDD workflow and testing guidelines - 80% coverage requirement
globs: 
alwaysApply: true
---

# Testing Guidelines

## TDD Workflow

```
RED → GREEN → REFACTOR
```

1. **Define Interfaces** - Types and contracts first
2. **Write Failing Tests** - Tests should fail initially
3. **Implement Minimal Code** - Just enough to pass
4. **Verify Tests Pass** - Run test suite
5. **Refactor** - Improve code quality
6. **Check Coverage** - Ensure 80%+ coverage

## Coverage Requirements

- **80% minimum** overall coverage
- **100%** for critical business logic
- Focus on meaningful tests, not just coverage numbers

## Test Types

### Unit Tests
- Individual functions
- Pure logic
- Utilities
- Fast execution

### Integration Tests
- API endpoints
- Database operations
- External service interactions

### E2E Tests
- Critical user flows
- Complete workflows
- Browser-based testing

## Test Structure

```typescript
describe('UserService', () => {
  describe('createUser', () => {
    it('creates user with valid input', async () => {
      // Arrange
      const input = { email: 'test@example.com', name: 'Test' }
      
      // Act
      const result = await createUser(input)
      
      // Assert
      expect(result.id).toBeDefined()
      expect(result.email).toBe(input.email)
    })

    it('throws error for invalid email', async () => {
      const input = { email: 'invalid', name: 'Test' }
      await expect(createUser(input)).rejects.toThrow('Invalid email')
    })
  })
})
```

## Best Practices

**DO:**
- Write tests FIRST (TDD)
- Test edge cases
- Keep tests independent
- Use descriptive test names
- Mock external dependencies

**DON'T:**
- Test implementation details
- Create test dependencies
- Skip error scenarios
- Write flaky tests
